|Propriété|Description|Options|
|--- |--- |--- |
|`abi.type`|**Type ABI** &ndash; Spécifie le type ABI (interface binaire d’application) du périphérique émulé. Le **x86** option est de l’instruction de définir communément appelée « x86 » ou « IA-32. » Le **x86_64** option concerne le x86 64 bits jeu d’instructions. Le **armeabi-v7a** option est pour le jeu avec les extensions ARM a v7 d’instructions ARM. Le **arm64-v8a** option est pour le jeu d’instructions ARM qui prend en charge AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Mettre en cache de la partition** &ndash; détermine si le périphérique émulé doit utiliser un **/cache** partition sur l’appareil. Le **/cache** partition (qui est vide) est l’emplacement où Android stocke des données fréquemment sollicitées et les composants de l’application. Si la valeur **aucun**, l’émulateur n’utilise pas un **/cache** partition et l’autre `disk.cache` paramètres seront ignorés.|yes, no|
|`disk.cachePartition.path`|**Chemin d’accès de la partition du cache** &ndash; spécifie un fichier d’image de partition du cache sur votre ordinateur de développement. L’émulateur utilisera ce fichier pour le **/cache** partition. Entrez un chemin d’accès absolu ou un chemin d’accès relatif au répertoire de données de l’émulateur. Si non définie, l’émulateur crée un fichier temporaire vide appelé **cache.img** sur votre ordinateur de développement. Si le fichier n’existe pas, il est créé comme un fichier vide. Cette option est ignorée si `disk.cachePartition` a la valeur **aucun**.||
|`disk.cachePartition.size`|**Taille de la partition du cache** &ndash; la taille du fichier de partition du cache (en mégaoctets). Vous n’avez normalement pas besoin de définir cette option, sauf si l’application télécharge des fichiers très volumineux qui dépassent la taille de cache par défaut de 66 mégaoctets. Cette option est ignorée si `disk.cachePartition` a la valeur **aucun**.||
|`disk.dataPartition.initPath`|**Chemin d’accès initial à la partition de données** &ndash; Spécifie le contenu initial de la partition de données. Après réinitialisation de données utilisateur, l’émulateur copie le contenu du fichier spécifié pour les données utilisateur (par défaut, **userdata-qemu.img**) au lieu d’utiliser **userdata.img** en tant que la version initiale.||
|`disk.dataPartition.path`|**Chemin d’accès à la partition de données** &ndash; Spécifie le fichier de partition de données utilisateur. Pour configurer un fichier de données utilisateur persistant, entrez un nom de fichier et un chemin d’accès sur votre ordinateur de développement. Si le fichier n’existe pas, l’émulateur crée une image à partir du fichier par défaut **userdata.img**, stocke le nom de fichier spécifié par `disk.dataPartition.path`, et conserve les données de l’utilisateur lui lorsque l’émulateur s’arrête. Si vous ne spécifiez pas un chemin d’accès, le fichier par défaut se nomme **userdata-qemu.img**. La valeur spéciale  **<temp>**  , l’émulateur créer et utiliser un fichier temporaire. Si `disk.dataPartition.initPath` est défini, son contenu est copié dans le fichier disk.dataPartition.path au moment du démarrage. Notez que cette option ne peut pas être vide.||
|`disk.dataPartition.size`|**Taille de partition de données** &ndash; spécifie la taille de la partition de données utilisateur en mégaoctets.||
|`disk.ramdisk.path`|**Chemin d’accès de disque virtuel** &ndash; chemin d’accès à l’image de la partition (ramdisk) de démarrage. L’image ramdisk est un sous-ensemble de l’image système chargé par le noyau avant que l’image système soit montée. L’image ramdisk contient généralement des fichiers binaires de démarrage et des scripts d’initialisation. Si cette option n’est pas spécifiée, la valeur par défaut est **ramdisk.img** dans le répertoire de système d’émulateur.||
|`disk.snapStorage.path`|**Chemin d’accès de stockage instantané** &ndash; chemin d’accès du fichier de stockage snapshot où tous les instantanés sont stockés. Toutes les captures instantanées effectuées pendant l’exécution seront enregistrées dans ce fichier. Seules les captures instantanées enregistrées dans ce fichier peuvent être restaurées au cours de l’exécution de l’émulateur. Si cette option n’est pas spécifiée, la valeur par défaut est snapshots.img dans le répertoire de données d’émulateur.||
|`disk.systemPartition.initPath`|**Le chemin d’accès de système partition init** &ndash; chemin d’accès à la copie en lecture seule du fichier image du système ; plus précisément, la partition contenant les bibliothèques système et les données correspondant au niveau de l’API et de type variant. Si ce chemin d’accès n’est pas spécifié, la valeur par défaut est system.img dans le répertoire de système d’émulateur.||
|`disk.systemPartition.path`|**Chemin d’accès de la partition système** &ndash; chemin d’accès à l’image de partition de système de lecture/écriture. Si ce chemin d’accès n’est pas définie, un fichier temporaire sera créé et initialisé à partir du contenu du fichier spécifié par `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Taille de la partition système** &ndash; la taille idéale de la partition système (en mégaoctets). La taille est ignorée si l’image de la partition système est supérieure à ce paramètre ; dans le cas contraire, il spécifie la taille maximale que peut atteindre le fichier de partition système.||
|`hw.accelerometer`|**Accéléromètre** &ndash; détermine si le périphérique émulé contient un capteur accéléromètre. L’accéléromètre permet à l’appareil de déterminer l’orientation (utilisée pour la rotation automatique). L’accéléromètre signale l’accélération de l’appareil le long des trois axes du capteur.|yes, no|
|`hw.audioInput`|**Prise en charge de l’enregistrement audio** &ndash; détermine si le périphérique émulé peut enregistrer le contenu audio.|yes, no|
|`hw.audioOutput`|**Prise en charge de lecture audio** &ndash; détermine si le périphérique émulé peut lire des données audio.|yes, no|
|`hw.battery`|**Prise en charge de la batterie** &ndash; détermine si le périphérique émulé peut s’exécuter sur une batterie.|yes, no|
|`hw.camera`|**Prise en charge de l’appareil photo** &ndash; détermine si le périphérique émulé dispose d’un appareil photo.|yes, no|
|`hw.camera.back`|**Appareil photo de face arrière** &ndash; configure l’appareil photo de face arrière (les faces thématique en s’éloignant de l’utilisateur). Si vous utilisez une webcam sur votre ordinateur de développement pour simuler l’appareil photo de face arrière sur le périphérique émulé, cette valeur doit être définie à la webcam*n*, où _n_ sélectionne la webcam (si vous n'avez qu’une webcam, Choisissez **webcam0**). Si la valeur émulées, l’émulateur simule l’appareil photo dans le logiciel. Pour désactiver l’appareil photo de face arrière, définissez cette valeur None. Si vous activez l’appareil photo de face arrière, veillez à activer également `hw.camera`.|emulated, none, webcam0|
|`hw.camera.front`|**Photo** &ndash; configure l’appareil photo de face (les faces thématique vers l’utilisateur). Si vous utilisez une webcam sur votre ordinateur de développement pour simuler la photo sur l’appareil émulé, cette valeur doit être définie à la webcam*n*, où _n_ sélectionne la webcam (si vous n'avez qu’une webcam Choisissez **webcam0**). Si la valeur émulées, l’émulateur simule un appareil photo dans le logiciel. Pour désactiver l’appareil photo de face, définissez cette valeur None. Si vous activez l’appareil photo de face, veillez à activer également `hw.camera`.|emulated, none, webcam0|
|`hw.camera.maxHorizontalPixels`|**Pixels de la caméra horizontal maximale** &ndash; configure la résolution horizontale maximale de l’appareil photo du périphérique émulé (en pixels).||
|`hw.camera.maxVerticalPixels`|**Pixels de la caméra verticale maximale** &ndash; configure la résolution verticale maximale de l’appareil photo du périphérique émulé (en pixels).||
|`hw.cpu.arch`|**Architecture d’UC** &ndash; architecture du processeur pour être émulés par le périphérique virtuel. Si vous utilisez pour l’accélération matérielle Intel HAXM, sélectionnez **x86** pour un processeur 32 bits. Sélectionnez **x86_64** pour un périphérique d’accélérée, HAXM 64 bits. (Veillez à installer l’image du système Intel x86 correspondante dans le Gestionnaire de kit de développement logiciel : par exemple, Intel x86 Atom ou Intel x86 Atom_64.) Pour simuler un processeur ARM, sélectionnez **arm** pour 32 bits ou sélectionnez **arm64** pour un processeur ARM de 64 bits. Gardez à l’esprit que les appareils virtuels ARM s’exécuteront beaucoup plus lentement que ceux de x86, car l’accélération matérielle n’est pas disponible pour ARM.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Modèle de processeur** &ndash; cette valeur est normalement pas définie (elle est définie à une valeur qui est dérivée de `hw.cpu.arch` si elle n’est pas explicitement définie). Toutefois, elle peut être définie sur une chaîne spécifique à l’émulateur pour une utilisation expérimentale.||
|`hw.dPad`|**Les clés DPad** &ndash; détermine si le périphérique émulé prend en charge les clés du pavé directionnel (DPad). Un DPad a en général quatre clés pour indiquer le contrôle directionnel.|yes, no|
|`hw.gps`|**Prend en charge les GPS** &ndash; détermine si le périphérique émulé possède un récepteur GPS (Global Positioning System).|yes, no|
|`hw.gpu.enabled`|**Émulation de GPU** &ndash; détermine si le périphérique émulé prend en charge l’émulation du GPU. Une fois activée, l’émulation du GPU utilise Open GL pour systèmes intégrés (OpenGL ES) pour le rendu des graphiques 2D et 3D sur l’écran et le paramètre Mode d’émulation du GPU associé détermine comment l’émulation du GPU est implémentée.|yes, no|
|`hw.gpu.mode`|**Mode d’émulation GPU** &ndash; détermine comment l’émulation de GPU est implémentée par l’émulateur. Si vous sélectionnez automatique, l’émulateur choisira l’accélération matérielle et logicielle en fonction de la configuration de votre ordinateur de développement. Si vous sélectionnez hôte, l’émulateur utilisera le processeur de graphique de votre ordinateur de développement pour effectuer l’émulation du GPU pour un rendu plus rapide. Si votre GPU n’est pas compatible avec l’émulateur et que vous êtes sous Windows, vous pouvez essayer d’angle au lieu de l’hôte. Le mode d’angle utilise DirectX pour fournir des performances similaires à l’hôte. Si vous sélectionnez MÉSA, l’émulateur utilisera la bibliothèque de logiciels 3D MÉSA pour restituer des graphiques. Sélectionnez MÉSA si vous rencontrez des problèmes de rendu par le processeur de graphique de votre ordinateur de développement. Le mode de swiftshader peut être utilisé pour restituer des graphiques dans le logiciel avec des performances légèrement moins que l’utilisation du GPU de l’ordinateur. L’option off (désactiver l’émulation de matériel graphique) est une option obsolète susceptibles de rendu inapproprié pour certains éléments et est donc pas recommandée.|auto, host, mesa, angle, swiftshader, off|
|`hw.gsmModem`|**Prise en charge du modem GSM** &ndash; détermine si le périphérique émulé inclut un modem qui prend en charge le système de cases d’option de téléphonie GSM (Global System for Mobile Communications).|yes, no|
|`hw.initialOrientation`|**Orientation de l’écran d’initiale** &ndash; configure l’orientation initiale de l’écran sur l’appareil émulé (mode portrait ou paysage). En mode portrait, l’écran est plus haut que large. En mode paysage, l’écran est plus large que haut. Lors de l’exécution de l’appareil émulé, vous pouvez modifier l’orientation si le mode portrait et le mode paysage sont tous les deux pris en charge dans le profil de l’appareil.|portrait, landscape|
|`hw.keyboard`|**Prise en charge du clavier** &ndash; détermine si le périphérique émulé prend en charge un clavier AZERTY.|yes, no|
|`hw.keyboard.charmap`|**Nom du clavier charmap** &ndash; le nom de la charmap matériel pour ce périphérique. Remarque : Cela doit toujours être la valeur par défaut **qwerty2** , sauf si vous avez modifié l’image du système en conséquence. Ce nom est envoyé au noyau au moment du démarrage. L’utilisation d’un nom incorrect entraîne un appareil virtuel inutilisable.||
|`hw.keyboard.lid`|**Prise en charge du capot de clavier** &ndash; prise en charge du clavier est activé, ce paramètre détermine si le clavier AZERTY peut être fermées/masquées ou visibles/ouvert. Ce paramètre sera ignoré si hw.keyboard est défini sur false. Remarque : la valeur par défaut est false si le périphérique émulé cible de niveau supérieur ou égal à 12 de l’API.|yes, no|
|`hw.lcd.backlight`|**Rétro** &ndash; détermine si un rétro est simulé par le périphérique émulé.|yes, no|
|`hw.lcd.density`|**Densité de l’écran** &ndash; la densité de l’affichage écran émulée, mesurée en pixels indépendants de densité, ou point de distribution (point de distribution est une unité virtuelle pixel). Lorsque le paramètre est de 160 dp, chaque dp correspond à un pixel physique. Lors de l’exécution, Android utilise cette valeur pour sélectionner et mettre à l’échelle les ressources/composants appropriés pour un rendu d’affichage correct.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Profondeur de couleur d’écran** &ndash; -résolution de la couleur du tampon de frame émulé qui contient l’image bitmap de commande d’affichage de l’écran. Cette valeur peut être de 16 bits (65 536 couleurs possibles) ou 32 bits (16 777 216 couleurs plus la transparence). Le paramètre de 32 bits permet à l’émulateur de s’exécuter légèrement plus lentement mais avec une meilleure précision des couleurs.|16, 32|
|`hw.lcd.height`|**Hauteur en pixels écran** &ndash; le nombre de pixels qui composent la dimension verticale de l’affichage écran émulée.||
|`hw.lcd.width`|**Largeur en pixels écran** &ndash; le nombre de pixels qui composent la dimension horizontale de l’affichage écran émulée.||
|`hw.mainKeys`|**Des clés précédent/Home matérielle** &ndash; détermine si le périphérique émulé prend en charge dans le matériel et les boutons de navigation accueil. Vous pouvez définir cette valeur sur **Oui** si les boutons sont implémentées uniquement dans le logiciel. Si `hw.mainKeys` a la valeur **Oui**, l’émulateur n’affichera pas les boutons de navigation à l’écran, mais vous pouvez utiliser le panneau émulateur « appuyer sur « ces boutons.|yes, no|
|`hw.ramSize`|**Périphérique de mémoire RAM** &ndash; la quantité de mémoire vive sur l’appareil émulée, en mégaoctets. La valeur par défaut est calculée à partir de la taille de l’écran ou de la version de l’apparence. L’augmentation de la taille peut fournir des opérations d’émulation plus rapide, mais au détriment d’une demande de ressources plus importante à partir de votre ordinateur de développement.||
|`hw.screen`|**Sélectionnez le type d’écran** &ndash; définit le type d’écran sur l’appareil émulé. Un écran tactile multi pouvez suivre deux ou plusieurs doigts sur l’interface tactile. Un écran tactile peut détecter uniquement les événements à un seul doigt tactile. Un écran non tactile ne détecte pas les événements tactiles.|touch, multi-touch, no-touch|
|`hw.sdCard`|**Prise en charge SDCard** &ndash; détermine si le périphérique émulé prend en charge d’insertion et la suppression de cartes SD (Secure Digital) virtuelles. L’émulateur utilise des images de disque monté stockés sur votre ordinateur de développement pour simuler les partitions de périphériques de carte SD réels (voir hw.sdCard.path).|yes, no|
|`sdcard.size`|**Taille de SDCard** &ndash; spécifie la taille du fichier de carte SD virtuel à l’emplacement spécifié par `hw.sdCard.path`. disponible sur l’appareil (en octets). Si la taille est un nombre entier simple, il spécifie la taille en octets. Vous pouvez également spécifier la taille en kilo-octets, mégaoctets et en gigaoctets, en ajoutant la taille K, M ou G. La taille minimale est de 9 M et la taille maximale est de 1 023 G.||
|`hw.sdCard.path`|**Chemin d’accès des images SDCard** &ndash; Spécifie le nom de fichier et le chemin d’accès à un fichier d’image SD carte partition sur votre ordinateur de développement. Par exemple, ce chemin d’accès peut être définie **C:\sd\sdcard.img** sur Windows.||
|`hw.sensors.magnetic_field`|**Capteur de champ magnétique** &ndash; détermine si le périphérique émulé prend en charge un capteur de champ magnétique. Le capteur de champ magnétique (également appelé magnétomètre) signale le champ géomagnétique ambiant mesuré le long des trois axes du capteur. Activez ce paramètre pour les applications qui ont besoin d’accéder à une lecture de boussole. Par exemple, une application de navigation peut utiliser ce capteur pour détecter la direction des faces utilisateurs.|yes, no|
|`hw.sensors.orientation`|**Orientation capteur** &ndash; détermine si le périphérique émulé fournit des valeurs de capteur orientation. Le capteur d’orientation mesure les degrés de rotation d’un appareil autour des trois axes physiques (x, y, z). Notez que le capteur d’orientation est déconseillé à compter d’Android 2.2 (API niveau 8).|yes, no|
|`hw.sensors.proximity`|**Capteur de proximité** &ndash; détermine si le périphérique émulé prend en charge un capteur de proximité. Ce capteur mesure la proximité d’un objet par rapport à l’écran d’affichage d’un appareil. Ce capteur est généralement utilisé pour déterminer si un combiné est actuellement tenu à proximité de l’oreille d’une personne.|yes, no|
|`hw.sensors.temperature`|**Capteur de température** &ndash; détermine si le périphérique émulé prend en charge un capteur de température. Capteur de cet mesure la température de l’appareil en degrés Celsius (&deg;C).|yes, no|
|`hw.touchScreen`|**Prise en charge de l’écran tactile,** &ndash; détermine si le périphérique émulé prend en charge un écran tactile. L’écran tactile est utilisé pour la manipulation directe d’objets à l’écran.|yes, no|
|`hw.trackBall`|**Prise en charge trackball** &ndash; détermine si le périphérique émulé prend en charge une boule de commande.|yes, no|
|`hw.useext4`|**Prise en charge de système de fichiers EXT4** &ndash; détermine si le périphérique émulé utilise le système de fichiers Linux EXT4 pour les partitions. Étant donné que le type de système de fichiers est désormais détecté automatiquement, cette option est déconseillée et ignorée.|Non|
|`kernel.newDeviceNaming`|**Noyau nouveau périphérique d’affectation de noms** &ndash; permet de spécifier si le noyau requiert un nouveau modèle d’affectation de noms de périphérique. Cela est généralement utilisé avec les noyaux Linux 3.10 et versions ultérieures. Si la valeur **autodetect**, l’émulateur détectera automatiquement si le noyau requiert un nouveau modèle d’affectation de noms de périphérique.|autodetect, yes, no|
|`kernel.parameters`|**Paramètres de noyau** &ndash; spécifie la chaîne de paramètres de démarrage du noyau Linux. Par défaut, ce paramètre est laissé vide.||
|`kernel.path`|**Chemin d’accès du noyau** &ndash; Spécifie le chemin d’accès pour le noyau Linux. Si ce chemin d’accès n’est pas spécifié, l’émulateur recherche dans le répertoire de système d’émulateur pour ranchu de noyau.||
|`kernel.supportsYaffs2`|**Prise en charge de la partition YAFFS2** &ndash; détermine si le noyau prend en charge YAFFS2 (encore une autre Flash fichier système 2) les partitions. En règle générale, cela s’applique uniquement aux noyaux avant Linux 3.10. Si la valeur **autodetect** l’émulateur détectera automatiquement si le noyau peut monter YAFFS2 des systèmes de fichiers.|autodetect, yes, no|
|`skin.name`|**Nom de l’apparence** &ndash; le nom d’un émulateur Android. Une apparence est une collection de fichiers qui définit les éléments visuels et de contrôle d’un affichage de l’émulateur ; elle décrit l’aspect de la fenêtre de l’appareil virtuel Android sur votre ordinateur de développement. Une apparence décrit la taille, les boutons et la conception générale de l’écran, mais elle n’affecte pas le fonctionnement de votre application.||
|`skin.path`|**Chemin d’accès de l’apparence** &ndash; chemin d’accès au répertoire qui contient les fichiers d’apparence émulateur spécifié dans skin.name ce répertoire contient des fichiers de mise en page hardware.ini et fichiers image pour les éléments d’affichage de l’apparence.||
|`skin.dynamic`|**L’apparence dynamique** &ndash; ou non l’apparence est dynamique. L’apparence de l’émulateur est une apparence dynamique si l’émulateur consiste à construire une apparence d’une taille donnée, selon une largeur et une hauteur spécifiées.|Non|

